# MPC Co-Signer Deployment Guide

This document details how to deploy the MPC Co-Signer service in a Linux environment.

## 1. Environment Requirements

- **Operating System**: Linux (Ubuntu 22.04 recommended)
- **Hardware Configuration**:
  - **Development/Test Environment**:
    - CPU: 2 Core+
    - RAM: 4GB+
    - Disk: 20GB+
  - **Production Environment (SGX environment recommended)**:
    - CPU: 8 Core+ (Intel SGX support required)
    - RAM: 64GB+
    - Disk: 40GB+
    - **SGX Support**: SGX support must be enabled in BIOS, and appropriate drivers installed.
- **Network Requirements**:
  - Must be able to access ChainUp Custody API (`https://openapi.chainup.com`)
  - Must open internal ports for Custody system calls (default 28888)

## 2. Preparation

Before starting deployment, please ensure you have:

1. Registered on the ChainUp Custody platform and obtained an `App ID`.
2. Prepared interface URLs for receiving withdrawal callbacks and Web3(optional) transaction callbacks .
3. Obtained the ChainUp RSA Public Key (available from the Custody management platform).

## 3. Automated Deployment (Recommended)

The project provides an `install.sh` script that automatically handles program download, key generation, and configuration initialization.

### Step 3.1: Get the Installation Package

If you already have the installation package, enter the directory. If you only have the script, ensure `install.sh` is in the working directory.

### Step 3.2: Run Installation Script

```bash
chmod +x install.sh
./install.sh
```

### Step 3.3: Follow Prompts

The script will interactively ask for the following information during execution:

1. **Installation Type**: Select `1) Standard` or `2) SGX` (Secure Mode).
2. **Cleanup Confirmation**: Confirm whether to clean up old configuration files (select Y for first-time installation).
3. **SGX Environment Setup (SGX Mode Only)**: The script will automatically check and install the `ego` environment (Ubuntu 22.04 only), and automatically download, sign, and bundle the SGX binary.
4. **App ID**: Enter your merchant App ID.
5. **Callback URLs**: Enter the callback URLs for withdrawals and Web3 transactions (press Enter to skip if not needed).
6. **Password Setup**: Set the startup password for Co-Signer (must be 16 characters). **Please remember this password, as it is required to start the service.**
7. **ChainUp Public Key**: Enter the ChainUp RSA Public Key obtained from the Custody platform.
8. **Business Public Key**: Enter the RSA Public Key used to verify withdrawal data (optional). The corresponding private key is generated by the client, and the client uses the RSA private key to sign withdrawal data when pushing withdrawals to the Custody platform.

### Step 3.4: Verify Installation

After the script finishes, it will automatically run a configuration check.

The directory structure will contain:

- `co-signer`: Main program
- `conf/config.yaml`: Configuration file
- `conf/keystore.json`: Key storage file
- `startup.sh`: Startup script
- `stop.sh`: Stop script

## 4. Manual Configuration (Advanced)

If you need to manually modify the configuration, please edit `conf/config.yaml`.

```yaml
main:
  # Co-signer service listening address
  tcp: "0.0.0.0:28888"
  # Encrypted storage file path
  keystore_file: "conf/keystore.json"

custody_service:
  # Merchant App ID
  app_id: "YOUR_APP_ID"
  # API Domain
  domain: "https://openapi.chainup.com/"
  # Language setting (zh_CN or en_US)
  language: "en_US"

custom_service:
  # Withdrawal callback address
  # This interface is used not only for withdrawal secondary confirmation but also for configuration self-check during Co-Signer startup (verifying public key configuration correctness)
  # Please refer to "Callback Interface Description" below for detailed protocol
  withdraw_callback_url: "http://your-service/callback/withdraw"
  # Web3 transaction callback address
  web3_callback_url: "http://your-service/callback/web3"
```

## 5. Callback Interface Description

### Withdrawal Callback Interface (`withdraw_callback_url`)

This interface has two purposes:

1. **Configuration Self-Check**: When running `./co-signer -check-conf`, this interface is called to verify the public key configuration.
2. **Withdrawal Secondary Confirmation**: When a withdrawal is initiated, Co-Signer calls this interface to request confirmation.

#### Configuration Self-Check Request Format

When `type` is `verify_public_hash`, it indicates a configuration self-check request.

**Request Parameters (POST JSON):**

```json
{
  "app_id": "YOUR_APP_ID",
  "client_system_pubkey_hash": "SHA256_HASH_OF_CLIENT_PUBKEY",
  "verify_sign_pub_hash": "SHA256_HASH_OF_VERIFY_SIGN_PUBKEY",
  "type": "verify_public_hash"
}
```

**Response Parameters (JSON):**

```json
{
  "client_system_pubkey_hash_valid": "SUCCESS", // or true
  "verify_sign_pub_hash_valid": "SUCCESS" // or true
}
```

#### Withdrawal Secondary Confirmation Request Format

When `type` is `sign_start`, it indicates a withdrawal secondary confirmation request.

**Request Parameters (POST JSON):**

```json
{
  "type": "sign_start",
  "withdraw_id": 12345,
  "request_id": "unique_request_id",
  "from": "address_from",
  "to": "address_to",
  "amount": "100.5",
  "symbol": "ETH",
  "memo": "optional_memo",
  "outputs": "optional_outputs"
}
```

**Response Parameters (String):**

Returns the string `SUCCESS` to indicate confirmation approval; any other return value indicates rejection.

## 6. Service Management

### Start Service

```bash
./startup.sh
```

You need to enter the password set previously when starting.

### Stop Service

```bash
./stop.sh
```

### View Logs

Logs are output to `nohup.out`.

```bash
tail -f nohup.out
```

## 7. Appendix: Public Key Hash Calculation Example

In the configuration self-check interface, `client_system_pubkey_hash` and `verify_sign_pub_hash` are calculated as follows: Use `app_id` as the key, perform HMAC-SHA256 calculation on the public key string (removing PEM headers/footers and newlines), and output a hexadecimal string.

### Java Example

```java
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public static String getSha256HashHex(String secret, String message) {
    try {
        // Remove PEM headers/footers and newlines
        message = message.replace("\n", "")
                         .replace("-----BEGIN PUBLIC KEY-----", "")
                         .replace("-----END PUBLIC KEY-----", "");

        Mac sha256_HMAC = Mac.getInstance("HmacSHA256");
        SecretKeySpec secret_key = new SecretKeySpec(secret.getBytes(), "HmacSHA256");
        sha256_HMAC.init(secret_key);
        byte[] bytes = sha256_HMAC.doFinal(message.getBytes("UTF-8"));
        return byteArrayToHexString(bytes);
    } catch (Exception e) {
        e.printStackTrace();
        return "";
    }
}

private static String byteArrayToHexString(byte[] b) {
    StringBuilder hs = new StringBuilder();
    String stmp;
    for (int n = 0; b != null && n < b.length; n++) {
        stmp = Integer.toHexString(b[n] & 0XFF);
        if (stmp.length() == 1)
            hs.append('0');
        hs.append(stmp);
    }
    return hs.toString().toLowerCase();
}
```

### Go Example

```go
import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "strings"
)

func getSha256HashHex(secret, data string) string {
    data = strings.ReplaceAll(data, "\n", "")
    data = strings.ReplaceAll(data, "-----BEGIN PUBLIC KEY-----", "")
    data = strings.ReplaceAll(data, "-----END PUBLIC KEY-----", "")
    h := hmac.New(sha256.New, []byte(secret))
    h.Write([]byte(data))
    return hex.EncodeToString(h.Sum(nil))
}
```
